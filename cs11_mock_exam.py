import operator

from collections import OrderedDict
from helpers import *

def substitution_cipher():
    """
    The substitution cipher is one of the simplest methods for encrypting text. The
    idea in this cipher is to substitute (or replace) each letter of the alphabet with
    another one. For example, suppose we have the following substitution table:
    INPUT a b c d e f g h i j k l m
    OUTPUT g j d f r v k n i s p u l
    INPUT n o p q r s t u v w x y z
    OUTPUT a y b e w m h x t o q z c
    On this table, each ‘a’ in our message will be replaced with ‘g’, ‘b’ will be
    replaced with ‘j’, ‘c’ will be replaced with ‘d’, and so on. Using the table, encrypting
    the message "watermelon" will result to the ciphertext "oghrwlruya".
    Your goal for this problem is to write a program that encrypts a message using
    substitution cipher.
    """
    n = 2
    input_test_cases = get_input_test_cases(n)

    base_keys = [
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    ]
    # first line is the message to be encrypted,
    # second line is the entries in the substitution table
    transformed_input_test_cases = [input_test_cases[i:i+n] for i in range(0, len(input_test_cases), n)]
    for test_case in transformed_input_test_cases:
        message = test_case[0].split()
        secret_keys = test_case[1]
        secret_keys = [i for i in secret_keys]

        encrypted_message = substituion_cipher(message, base_keys, secret_keys)

        print(encrypted_message)


def inventory_sequences():
    """
    An inventory sequence is an infinite sequence of numbers where each succeeding
    element is generated by “reading the inventory” of the current element.
    As an example, consider the following inventory sequence S = s0, s1, s2, . . .
    1, 11, 21, 1211, 111221, 312211, 13112221, 1113123211, 31131112131221, . . .
    Here, the start of the sequence s0 is 1. Since s0 has one 1 (1 − 1), the next
    element s1 is 11. Since 11 has two 1s (2 − 1), the next element s2 is 21, which
    is then followed by s3 = 1211, s4 = 111221, and so on.
    Write a program that outputs sn of an inventory sequence S, given a starting
    number s0.
    """
    input_test_cases = get_input_test_cases()

    for test_case in input_test_cases:
        test_case = test_case.split()
        start_num = int(test_case[0])
        end_count = int(test_case[1])

        reads = []
        reads.append(start_num)
        _counter = 1
        while True:
            if _counter > end_count:
                break

            # read
            string_current_number_to_read = str(reads[_counter - 1])
            current_read = inventory_reader(string_current_number_to_read)
            reads.append(current_read)
            _counter += 1

        print(reads[end_count])


def roman_numeral():
    """
    Write a program that converts a natural number in Hindu-Arabic form to Roman
    Numeral form
    """
    input_test_cases = get_input_test_cases()

    for test_case in input_test_cases:
        test_case = int(test_case)
        if test_case < 1 or test_case > 3999:
            print('Invalid Input')
            continue
        else:
            answer = write_roman_numeral(test_case)
            print(answer)


def uniquely_yours():
    """
    Write a program that determines all unique characters in a string.

    For each test case, output a line with unique characters (case insensitive) according
    to the number of occurrences and in cases of tie, sort them alphabetically.
    Ignore white space.
    """
    input_test_cases = get_input_test_cases()

    for test_case in input_test_cases:
        test_case = test_case.lower().replace(' ', '')
        data = data_counter(test_case)
        sorted_data = sorted(
            data.items(),
            key=operator.itemgetter(0))  # sort alpha
        sorted_data = sorted(
            sorted_data,
            key=operator.itemgetter(1),
            reverse=True)  # sort by occurence
        
        answer = ''
        for i in sorted_data:
            answer += i[0]

        print(answer)


def word_amalgamation():
    """
    In millions of newspapers across the United States there is a word game called
    Jumble. The objective of this game is to solve a riddle, but in order to find the
    letters that appear in the answer it is necessary to unscramble four words. Your
    task is to write a program that can unscramble words.
    """
    delimiter = "XXXXXX"
    dictionary = []
    scrambled_words = []  # (word: str, unscrambled: array)

    # get user inputs
    dictionary = get_infinite_inputs(delimiter)
    list_of_scrambled_words = get_infinite_inputs(delimiter, min_length=1, max_length=6)
    for word in list_of_scrambled_words:
        search_result = sorted(search_words(word, dictionary))
        scrambled_word = (
            word,
            search_result
        )
        scrambled_words.append(scrambled_word)

    # print results
    end_of_result_string = "******"
    for word_tuple in scrambled_words:
        unscrambled_words = word_tuple[1]
        if len(unscrambled_words) < 1:
            print('NOT A VALID WORD')
        else:
            for word in unscrambled_words:
                print(word)

        print(end_of_result_string)
